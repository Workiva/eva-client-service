{
	"info": {
		"_postman_id": "08348ffd-ec8a-45ce-a58c-5c898c3c8fd5",
		"name": "EVA-Client-Service - EVA 102",
		"description": "Currently Missing:\n- Historic Queries\n\t- Sorting\n- Datoms API\n\nWill not be Added:\n- Entity API (Lazy Loading)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Transact Schema",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[{:db/id #db/id [:db.part/user]\n   :db/ident :account/name\n   :db/valueType :db.type/string\n   :db/cardinality :db.cardinality/one\n   :db/doc \"An account's name\"\n   :db.install/_attribute :db.part/db}\n\n {:db/id #db/id [:db.part/user]\n  :db/ident :account/balance\n  :db/cardinality :db.cardinality/one \n  :db/valueType :db.type/long\n  :db/doc \"The accounts balance\"\n  :db.install/_attribute :db.part/db}\n]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "In Eva 101, we delved into the fundamentals of Eva.  We showed how schema was defined and transacted into the database.  We showed how transactions are also used to add data to the system.  Finally we went on a whirlwind tour of the query faculties provided by Eva.\n\nToday we will expose the basics of database functions and exceptions, look at various historical views of the database, and explore some API's in Eva that allow you to manipulate your data differently.\n\nFirst we will start with our schema, modeling that of account holders at a bank, and add a few entities to go along with it."
			},
			"response": []
		},
		{
			"name": "Transact Records",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "21e997b0-4754-41de-958a-6cfecbb18c49",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[{:db/id #db/id [:db.part/user -1]\n  :account/name \"Jeff Bridges\"}\n {:db/id #db/id [:db.part/user -1]\n  :account/balance 100}\n\n {:db/id #db/id [:db.part/user -2]\n  :account/name \"Jimmy Fallon\"}\n {:db/id #db/id [:db.part/user -2]\n  :account/balance 1000}\n\n {:db/id #db/id [:db.part/user -3]\n  :account/name \"Michael Jackson\"}\n {:db/id #db/id [:db.part/user -3]\n  :account/balance 10000}]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "In Eva 101, we delved into the fundamentals of Eva.  We showed how schema was defined and transacted into the database.  We showed how transactions are also used to add data to the system.  Finally we went on a whirlwind tour of the query faculties provided by Eva.\n\nToday we will expose the basics of database functions and exceptions, look at various historical views of the database, and explore some API's in Eva that allow you to manipulate your data differently.\n\nFirst we will start with our schema, modeling that of account holders at a bank, and add a few entities to go along with it."
			},
			"response": []
		},
		{
			"name": "CAS Account Balance",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "cc850cbb-f632-4095-be86-a373de4eec0f",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      if (parseInt(val[2]) == 100) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(200);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:db.fn/cas \n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                :label \"{{label}}\"\n              }\n              \"\\\"Jeff Bridges\\\"\"]\n            ]\n  }\n  :account/balance\n  100\n  200]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Let's add 100 dollars to the account of Jeff Bridges.\n\nWait, `:db.fn/cas`, what is that?  Compare-and-swap is a built-in database [function](https://github.com/Workiva/eva/blob/2dae6871ce8f38153da430018c1af9646da4355f/core/src/eva/builtin.clj#L31). It is used to update the value of a single datom, taking as arguments an entity id, attribute, an old value, and a new value.  A `:db.fn/cas` operation will succeed only if the old value you provide matches that which is found in the database at the time of the transaction.\n\nThis introduces somewhat of a problem, as we would ideally like to be able to update the balance without worrying about whether or not someone came in and modified the balance before us.  Enter the transaction function."
			},
			"response": []
		},
		{
			"name": "Transact Increment Balance TX Function",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "fbcb2a02-d69e-4c90-8215-b4e538fc27a3",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    pm.expect(pm.response.text()).to.include(\":code\");",
							"    pm.expect(pm.response.text()).to.include(\":params\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[{:db/id #db/id [:db.part/user -1]\n  :db/ident :inc-balance\n  :db/doc \"Data function that increments value of attribute by an amount.\"\n  :db/fn #db/fn {:lang \"clojure\"\n                 :params [db e amount]\n                 :code [[:db/add e\n                         :account/balance\n                         (-> (d/entity db e) :account/balance (+ amount))]]}}]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Transaction functions are a subset of database functions which run inside a transaction.  They must accept a `db` value as their first argument, and return a valid list of transaction data.  In this case we are going to define and install a function that will run as part of our transaction to ensure atomicity when incrementing the balance of an account:\n\nFirstly, notice the similarities between this function and the functions we've seen up to this point.  We re-use a number of `:db` keywords such as id, identity, and docstring.  The new one here is `:db/fn`, which is just a map used to describe the function.\n\nEnclosed in `:db/fn` is `:lang`, which defines the language we wish to write our function in.  Currently we only support \"clojure\" but we expect to support \"java\" sometime in the future.  The first argument to the `:params` keyword must be a `db` value, followed by any other parameters (up to 20) that you want to pass to the function.  In this case we are passing an entity id `e`, and the `amount` we wish to add to the account's balance.\n\nLet's go through the logic inside the `:code` block.  The first part we've seen before, and is simply the signature for `:db/add` except that the value is derived from `(-> (d/entity db e) :account/balance (+ amount))`.\n\n`->` is a [thread-first macro](https://clojure.org/guides/threading_macros) we use to pass the result of a form as the first argument to the next form.  It allows us to read code in an imperative style.  So first, we fetch the entity `e` from the database, then read off `:account/balance` from that entity and then finally add to the read balance the `amount`.\n\nOne important thing to note is that inside the code block of a transaction function, we alias [d](https://github.com/Workiva/eva/blob/master/core/src/eva/functions.clj#L53}) as the namespace when accessing Eva API functions."
			},
			"response": []
		},
		{
			"name": "Update Account Balance",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "7affd1e7-90bf-4acb-91eb-dc762329892c",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      if (parseInt(val[2]) == 200) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(230);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:inc-balance \n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n              \"\\\"Jeff Bridges\\\"\"]]}\n  30]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "There you have it, we've successfully updated the balance of the account by 30.  We simply call the `:inc-balance` keyword as part of the transaction, supplying it with our entity id and the amount by which we want the account balance incremented.  The `db` value is passed implicitly to the transaction function, so it does not need to be explicitly specified."
			},
			"response": []
		},
		{
			"name": "Transact Transfer TX Function",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    pm.expect(pm.response.text()).to.include(\":code\");",
							"    pm.expect(pm.response.text()).to.include(\":params\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n    :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[{:db/id #db/id [:db.part/user -1]\n  :db/ident :transfer\n  :db/doc \"Data function that transfers an amount from one account to another.\"\n  :db/fn #db/fn{\n    :lang \"clojure\"\n    :params [db from to amount]\n    :code (let [from-entity (d/entity db from)\n                from-balance (-> from-entity :account/balance (- amount))\n                to-balance (-> (d/entity db to) :account/balance (+ amount))]\n            (if (< from-balance 0)\n              (throw\n                (IllegalStateException.\n                  (str \"Transfer exception: Balance cannot be negative, current balance: \"\n                    (from-entity :account/balance))))\n              [{:db/id from :account/balance from-balance}\n               {:db/id to :account/balance to-balance}]))}}]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "We can take this a step further by creating another transaction function so that we can transfer between existing accounts.\n\nMost of this is similar to the `:inc-balance` function we defined earlier, minus the addition of [let](https://clojuredocs.org/clojure.core/let).  Let is a core concept of Clojure and allows us to define variables that are available only within the scope of the function.  This helps clean up the code a bit, and obviously allows us to re-use values."
			},
			"response": []
		},
		{
			"name": "Transfer Money Cross Accounts",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      if (parseInt(val[2]) == 10000) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(4999);",
							"      }",
							"      // Test Case #2",
							"      if (parseInt(val[2]) == 230) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(5231);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:transfer\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n             [#eva.client.service/snapshot-ref {\n                :label \"{{label}}\"\n              }\n             \"\\\"Michael Jackson\\\"\"]]}\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n             [#eva.client.service/snapshot-ref {\n                :label \"{{label}}\"\n              }\n             \"\\\"Jeff Bridges\\\"\"]]}\n             5001]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "With this, we transfer 5000 from Michael Jackson's account into Jeff Bridge's account, as can be deduced from the result of the transaction."
			},
			"response": []
		},
		{
			"name": "Datoms - Single Component - :eavt",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    pm.expect(datoms.length).to.eql(2);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/snapshot-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "index",
							"value": ":eavt",
							"type": "text"
						},
						{
							"key": "components",
							"value": "8796093023234",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/datoms/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"datoms",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "With this, we transfer 5000 from Michael Jackson's account into Jeff Bridge's account, as can be deduced from the result of the transaction."
			},
			"response": []
		},
		{
			"name": "Datoms - Multiple Components - :eavt",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    pm.expect(datoms.length).to.eql(1);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/snapshot-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "index",
							"value": ":eavt",
							"type": "text"
						},
						{
							"key": "components",
							"value": "[8796093023234 8796093023232]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/datoms/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"datoms",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "With this, we transfer 5000 from Michael Jackson's account into Jeff Bridge's account, as can be deduced from the result of the transaction."
			},
			"response": []
		},
		{
			"name": "Datoms - Multiple Components Nothing - :eavt",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    pm.expect(datoms).to.eql(null);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/snapshot-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "index",
							"value": ":eavt",
							"type": "text"
						},
						{
							"key": "components",
							"value": "[8796093023234 8796093023232 nil]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/datoms/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"datoms",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "With this, we transfer 5000 from Michael Jackson's account into Jeff Bridge's account, as can be deduced from the result of the transaction."
			},
			"response": []
		},
		{
			"name": "Transact Audit Schema",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[\n {:db/id #db/id [:db.part/db]\n  :db/ident :audit/from\n  :db/valueType :db.type/long\n  :db/cardinality :db.cardinality/one\n  :db/doc \"Origin account for transfer\"\n  :db.install/_attribute :db.part/db}\n\n {:db/id #db/id [:db.part/db]\n  :db/ident :audit/to\n  :db/cardinality :db.cardinality/one\n  :db/valueType :db.type/long\n  :db/doc \"Destination account for transfer\"\n  :db.install/_attribute :db.part/db}\n\n {:db/id #db/id [:db.part/db]\n  :db/ident :audit/amount\n  :db/valueType :db.type/long\n  :db/cardinality :db.cardinality/one\n  :db/doc \"Amount of transfer\"\n  :db.install/_attribute :db.part/db}\n\n {:db/id #db/id [:db.part/db]\n  :db/ident :audit/reason\n  :db/valueType :db.type/string\n  :db/cardinality :db.cardinality/one\n  :db/doc \"Reason for transfer\"\n  :db.install/_attribute :db.part/db}\n]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "We touched on transaction entities briefly in 101, now we are going to take a closer look.  As you well know by this point, a transaction entity is created for every successful transaction.  By default, the only attribute stored on the transaction entity is `:db/txInstant`, whose value is the time at which the transaction occurred.  The transaction entity can be used for much more, let's look at an example:\n\nSo we've transacted a few more attributes into the database that we can use to add metadata to transactions."
			},
			"response": []
		},
		{
			"name": "Transact Transfer TX Function w/ Metadata",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    pm.expect(pm.response.text()).to.include(\":code\");",
							"    pm.expect(pm.response.text()).to.include(\":params\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[{:db/id #db/id [:db.part/user -1]\n  :db/ident :transfer\n  :db/doc \"Data function that transfers an amount from one account to another.\"\n  :db/fn #db/fn\n         {:lang \"clojure\"\n          :params [db from to amount reason]\n          :code (let [from-entity (d/entity db from)\n                      from-balance (-> from-entity :account/balance (- amount))\n                      to-balance (-> (d/entity db to) :account/balance (+ amount))]\n                  (if (< from-balance 0)\n                    (throw\n                      (IllegalStateException.\n                        (str \"Transfer exception: Balance cannot be negative, current balance: \"\n                          (from-entity :account/balance))))\n                    [{:db/id from\n                      :account/balance from-balance}\n                     {:db/id to\n                      :account/balance to-balance}\n                     {:db/id (d/tempid :db.part/tx)\n                      :audit/from from}\n                     {:db/id (d/tempid :db.part/tx)\n                      :audit/to to}\n                     {:db/id (d/tempid :db.part/tx)\n                      :audit/amount amount}\n                     {:db/id (d/tempid :db.part/tx)\n                      :audit/reason reason}]))}}]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Next we'll modify our `transfer` database function to make use of this metadata.\n\nWe've added the `:audit` attributes in our `transfer` transaction function.  This will allow us to capture the `from` and `to` account entity id's for the transfer, as well as the `amount` and the `reason` for the transfer.  Up until this point we've only dealt with `:db.part/db` when calling `eva/tempid` but here we call `(d/tempid :db.part/tx)`.  In this case we ask the transaction partition (`:db.part/tx`) for the temporary id that will be used for the transaction entity generated by this transaction and we can use that to associate other attributes with it."
			},
			"response": []
		},
		{
			"name": "Transfer Money - Royalities",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    pm.expect(pm.response.text()).to.include(\"Royalities.\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      // Search for Previous (Retracted Value)",
							"      if (parseInt(val[2]) == 4999) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(5999);",
							"      }",
							"      // Test Case #2",
							"      if (parseInt(val[2]) == 5231) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(4231);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:transfer\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Jeff Bridges\\\"\"]]}\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Michael Jackson\\\"\"]]}\n  1000\n  \"Royalities.\"]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Let's run some transactions that will actually make use of these new `:audit` attributes"
			},
			"response": []
		},
		{
			"name": "Transfer Money - Obvious Money Laundering",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    pm.expect(pm.response.text()).to.include(\"Obvious Money Laundering.\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      // Search for Previous (Retracted Value)",
							"      if (parseInt(val[2]) == 5999) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(6499);",
							"      }",
							"      // Test Case #2",
							"      if (parseInt(val[2]) == 1000) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(500);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:transfer\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Jimmy Fallon\\\"\"]]}\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Michael Jackson\\\"\"]]}\n  500\n  \"Obvious Money Laundering.\"]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Let's run some transactions that will actually make use of these new `:audit` attributes"
			},
			"response": []
		},
		{
			"name": "Transfer Money - Charity",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    pm.expect(pm.response.text()).to.include(\"Charity.\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      // Search for Previous (Retracted Value)",
							"      if (parseInt(val[2]) == 6499) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(6999);",
							"      }",
							"      // Test Case #2",
							"      if (parseInt(val[2]) == 500) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(0);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:transfer\n#eva.client.service/inline { \n    :fn query \n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Jimmy Fallon\\\"\"]]}\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Michael Jackson\\\"\"]]}\n  500\n  \"Charity.\"]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Let's run some transactions that will actually make use of these new `:audit` attributes"
			},
			"response": []
		},
		{
			"name": "Transfer Money - Land Transfer Tax",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    pm.expect(pm.response.text()).to.include(\"Land transfer tax.\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      // Search for Previous (Retracted Value)",
							"      if (parseInt(val[2]) == 6999) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(9499);",
							"      }",
							"      // Test Case #2",
							"      if (parseInt(val[2]) == 4231) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(1731);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:transfer\n#eva.client.service/inline { \n    :fn query \n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Jeff Bridges\\\"\"]]}\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Michael Jackson\\\"\"]]}\n  2500\n  \"Land transfer tax.\"]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Let's run some transactions that will actually make use of these new `:audit` attributes"
			},
			"response": []
		},
		{
			"name": "Transfer Money - Vast Amounts of Donuts",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "c6e12775-8e17-45d1-bc51-418497c0de29",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body matches string\", function () {",
							"    pm.expect(pm.response.text()).to.include(\":tempids\");",
							"    pm.expect(pm.response.text()).to.include(\":db-before\");",
							"    pm.expect(pm.response.text()).to.include(\":tx-data\");",
							"    pm.expect(pm.response.text()).to.include(\":db-after\");",
							"    ",
							"    pm.expect(pm.response.text()).to.include(\"Vast amounts of donuts.\");",
							"    ",
							"    var resp = pm.response.text();",
							"    var datoms = resp.match(/(#datom\\[([^\\s]+\\s){2}([^\\s]+\\s){1,2}([^\\s]+\\s){1}(true|false)\\])/g);",
							"    var addedDatoms = new Map();",
							"    var retractedDatoms = new Map();",
							"    for (var i = 0; i < datoms.length; i++) {",
							"        trimmedDatom = datoms[i].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"        eid = trimmedDatom[0];",
							"        for (var j = 0; j < datoms.length; j++) {",
							"            tempTrimmedDatom = datoms[j].replace(\"#datom\", \"\").trim().slice(1, -1).split(/\\s+/g);",
							"            if (j != i && eid == tempTrimmedDatom[0]) {",
							"                if (trimmedDatom[4] == \"true\") {",
							"                    addedDatoms.set(eid, trimmedDatom);",
							"                    retractedDatoms.set(eid, tempTrimmedDatom);",
							"                } else {",
							"                    addedDatoms.set(eid, tempTrimmedDatom);",
							"                    retractedDatoms.set(eid, trimmedDatom);",
							"                }",
							"            }",
							"        }",
							"    }",
							"    ",
							"    for (var [key, val] of retractedDatoms.entries()) {",
							"      // Test Case #1",
							"      // Search for Previous (Retracted Value)",
							"      if (parseInt(val[2]) == 1731) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(731);",
							"      }",
							"      // Test Case #2",
							"      if (parseInt(val[2]) == 9499) {",
							"        // Skip entity values",
							"        if (parseInt(addedDatoms.get(key)[2]) > 8000000000000) {",
							"          continue;",
							"        }",
							"        pm.expect(parseInt(addedDatoms.get(key)[2])).to.eql(10499);",
							"      }",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n    :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "transaction",
							"value": "[[:transfer\n#eva.client.service/inline { \n    :fn query \n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Jeff Bridges\\\"\"]]}\n  #eva.client.service/inline {\n    :fn query\n    :params [\"[:find ?e .\n               :in $ ?name\n               :where [?e :account/name ?name]]\"\n              [#eva.client.service/snapshot-ref {\n                 :label \"{{label}}\"\n               }\n               \"\\\"Michael Jackson\\\"\"]]}\n  1000\n  \"Vast amounts of donuts.\"]]",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/transact/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"transact",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Let's run some transactions that will actually make use of these new `:audit` attributes"
			},
			"response": []
		},
		{
			"name": "Query TXs for a Michael Jackson's Account",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "0e060d2a-1388-4dee-a59e-4ae1a6c9b456",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body is correct\", function () {",
							"    var resp = pm.response.text().slice(1, -1);",
							"    pm.expect(resp.split(/\\s+/).length).to.eql(5);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "query",
							"value": "[:find [?tx-id ...]\n :in $ ?account-id\n :where [?tx-id :audit/to ?account-id]]",
							"type": "text"
						},
						{
							"key": "p[0]",
							"value": "#eva.client.service/snapshot-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "p[1]",
							"value": "#eva.client.service/inline {\n  :fn query\n  :params [\"[:find ?e .\n             :in $ ?name\n             :where [?e :account/name ?name]]\"\n           [#eva.client.service/snapshot-ref {\n              :label \"{{label}}\"\n            }\n            \"\\\"Michael Jackson\\\"\"]]}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/q/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"q",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Query for all transaction entity ids where the passed in `account-id` matches the value for the `:audit/to` attribute."
			},
			"response": []
		},
		{
			"name": "Entire Transaction Log",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "0e060d2a-1388-4dee-a59e-4ae1a6c9b456",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body is correct\", function () {",
							"    var resp = pm.response.text();",
							"    var txEntries = resp.match(/(:t \\d+)/g);",
							"    ",
							"    pm.expect(txEntries.length).to.eql(14);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "reference",
							"value": "#eva.client.service/connection-ref {\n  :label \"{{label}}\"\n}",
							"type": "text"
						},
						{
							"key": "start",
							"value": "0",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/tx-range/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"tx-range",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Included within Eva is a database log of all transaction data in historic order.\n\nVoil, all the datoms from the beginning of the log to the latest transaction (because `end` is omitted) are returned as a list of maps. Inside each map are two keys, `:t`, containing the transaction number, and `:data`, containing the datoms asserted or retracted as part of that transaction."
			},
			"response": []
		},
		{
			"name": "As-Of - Query Michael Jackon's Previous Account Balance",
			"event": [
				{
					"listen": "test",
					"script": {
						"id": "0e060d2a-1388-4dee-a59e-4ae1a6c9b456",
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(500);",
							"});",
							"",
							"pm.test(\"Body is correct\", function () {",
							"    var resp = pm.response.text().slice(2, -2);",
							"    pm.expect(parseInt(resp)).to.eql(10000);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/vnd.eva+edn"
					},
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "query",
							"value": "[:find ?bal \n :in $ ?name \n :where [?e :account/name ?name]\n        [?e :account/balance ?bal]]",
							"type": "text"
						},
						{
							"key": "p[0]",
							"value": "#eva.client.service/snapshot-ref {\n  :label \"{{label}}\"\n  :as-of 3\n}",
							"type": "text"
						},
						{
							"key": "p[1]",
							"value": "\"Michael Jackson\"",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{host}}:{{port}}/eva/{{ver}}/q/{{tenant}}/{{category}}",
					"host": [
						"{{host}}"
					],
					"port": "{{port}}",
					"path": [
						"eva",
						"{{ver}}",
						"q",
						"{{tenant}}",
						"{{category}}"
					]
				},
				"description": "Query for all transaction entity ids where the passed in `account-id` matches the value for the `:audit/to` attribute."
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "b367ea4f-e8ee-4b99-8689-34c69ddf43dc",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "0e19b853-0d25-4100-aabe-b3c18dda472f",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}